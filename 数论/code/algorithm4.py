# -*- coding: utf-8 -*-
# @Time    : 2020/3/10 20:07
# @Author  : XiaoMa（小马）
# @qq      : 1530253396（任何问题欢迎联系）
# @File    : algorithm4.py
# gcd,求最大公约数函数，递归算法，有了扩展欧几里得算法之后，此函数可以不用
def _g_c_d(a, b):
    if 0 == b:
        return a
    return gcd(b, a % b)

def Ex_Euclid(a, b):
    if 0 == b:
        x = 1;
        y = 0;
        q = a
        return x, y, q
    xyq = Ex_Euclid(b, a % b)
    x = xyq[0];
    y = xyq[1];
    q = xyq[2]
    temp = x;
    x = y;
    y = temp - a // b * y
    return x, y, q


# 获取a的逆元(mod b)的函数，目的是为了封装获取逆元的功能
def Get_Inverse(a, b):
    return Ex_Euclid(a, b)[0]


# 获取a和b的最大公约数函数，目的是为了封装获取最大公约数的功能
def gcd(a, b):
    return Ex_Euclid(a, b)[2]


# 判断所有的mi是否两两互质
def Is_Coprime(m_list):
    for i in range(len(m_list)):
        for j in range(i + 1, len(m_list)):
            if 1 != gcd(m_list[i], m_list[j]):
                return 0  # 返回0表示不是两两互质的
    return 1  # 返回1表示是两两互质的


# 获取所有的Mi
def Get_Mi(m_list, M):
    Mi_list = []
    for mi in m_list:
        Mi_list.append(M // mi)
    return Mi_list


# 获取所有的Mi的逆元
def Get_Mi_inverse(Mi_list, m_list):
    Mi_inverse = []
    for i in range(len(Mi_list)):
        Mi_inverse.append(Get_Inverse(Mi_list[i], m_list[i]))
    return Mi_inverse


# 中国剩余定理,返回值为最终的x
def C_R_T(m_list, b_list):
    M = 1  # M是所有mi的乘积
    for mi in m_list:
        M *= mi
    Mi_list = Get_Mi(m_list, M)
    Mi_inverse = Get_Mi_inverse(Mi_list, m_list)
    x = 0
    for i in range(len(b_list)):  # 开始计算x
        x += Mi_list[i] * Mi_inverse[i] * b_list[i]
        x %= M
    print(f"{m_list},{b_list}\n同余式组的解为：x=%d\n" % x)


if __name__ == '__main__':
    a = [
        [23,28,33],
        [23,28,33],
        [23,28,33],
        [489808178709479466279507878773770708214878979673,896234965496726578561614071442814700467907036641,1213827005758305602466882992172310409456053868843],
        [8157969540288411637818433039558323184074779086100165504668538221920170369774913261335059602331627321130656458962980224196880533337839226059601303464776145,9699616044315021194953572561076502992783130623216574220426043600142343504101508838526221359049417564415801914072315788919275792502477693022853881785198116,7832693802256371667866514213119452199821916193668106904135812283217637737600922381702016472708855675649121271702977408217814917908566132517503707494037556]
    ]
    b = [
        [0,0,0],
        [5,20,34],
        [283,102,23],
        [802310684485241212312289432691586430708135062249,961714109955647014172499578071923389425123540027,1381194006087304024683552712488022595194097928701],
        [13392316081651420877308875276166772808601812122052371442339078877740399569281672683820206196320955005869072002883847646526584107260355414977120453263391947,9734466939658282823343760206593283968765904848250021580218634383869090913086348857668999272399075016287736914000854272239315769632719896968098820774563511,9460200357790728398862913232664036038694521858415765931064505193755202156521446156499075450033429983317127589636591133111239548821251790171694322930011927]
    ]
    for i,j in zip(a,b):
        C_R_T(i, j)


